Messages
========

The Message table is a central message spool that can be used by
various parts of launchpad. Currently, it is used by Malone for comments
on bugs. Bugs are linked to Messages via the BugMessage table.

    >>> from lp.services.webapp.interfaces import IOpenLaunchBag
    >>> from lp.bugs.interfaces.bug import IBugSet
    >>> from lp.bugs.interfaces.bugmessage import IBugMessageSet
    >>> login("foo.bar@canonical.com")
    >>> bugmessageset = getUtility(IBugMessageSet)
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> current_user = getUtility(IOpenLaunchBag).user
    >>> bmsg = bugmessageset.createMessage(
    ...     subject="The Title",
    ...     content="The Content",
    ...     bug=bug_one,
    ...     owner=current_user,
    ... )
    >>> msg = bmsg.message
    >>> print(msg.subject)
    The Title

We can retrieve the text chunks as a unicode string. (However, note that
if generating HTML you should use the MessageChunks detailed below
to handle attachments correctly)

    >>> print(msg.text_contents)
    The Content

Messages are threaded, although this is not necessarily displayed in the
UI. Each message has a parent attribute. If the message was created via
IBugMessageSet, the parent gets set to the bug's initial message.

    >>> msg.parent == bug_one.initial_message
    True

Messages always have a message id, which is used when notifications
of this message are sent out. The message id is generated by the system
if not provided

    >>> import six
    >>> isinstance(msg.rfc822msgid, str)
    True
    >>> bool(msg.rfc822msgid)
    True

A Message is made up of one or more chunks. The chunks are stored in the
MessageChunk table. The majority of messages will have a single chunk
representing the text body of the message. More complex messages, such as
an email with attachments, will contain multiple chunks. A chunk may be a
piece of text, or a reference to an object stored in the Librarian. Chunks
may be accessed using the chunks attribute, or simply by iterating over
the Message.

    >>> for chunk in msg:
    ...     print(pretty([chunk.sequence, chunk.content, chunk.blob]))
    ...
    [1, 'The Content', None]
    >>> msg.chunks[0].message == msg
    True

You can build a Message from an email easily. This stuffs the original,
unadulterated, email into the Librarian and builds all the MessageChunks.

    >>> from lp.services.messages.interfaces.message import IMessageSet
    >>> msgset = getUtility(IMessageSet)
    >>> raw_msg = """\
    ... Content-Type: multipart/mixed; charset="latin-1";
    ...               boundary="===============0294339828=="
    ... MIME-Version: 1.0
    ... Subject: =?utf-8?q?Unicode=E2=84=A2?=
    ... From: foo.bar@canonical.com
    ... Message-Id: <20050405054002.22134.71562@localhost.localdomain>
    ... Date: Thu Jun 16 14:12:54 BST 2005
    ... To: cabal@ubuntu.com
    ...
    ... The preamble is not included, including Unicode\N{COPYRIGHT SIGN}
    ... --===============0294339828==
    ... Content-Type: text/plain; charset="us-ascii"
    ... MIME-Version: 1.0
    ... Content-Transfer-Encoding: 7bit
    ...
    ... Plain text
    ... --===============0294339828==
    ... Content-Type: executable/virus
    ... MIME-Version: 1.0
    ... Content-Transfer-Encoding: base64
    ... Content-Disposition: attachment; filename="anna.jpg.exe"
    ... X-Comment: A trivial binary containing bytes 0x00 0x01 0x02 0x03
    ... X-Comment: This also tests embedded NULLs in the blobs
    ... X-Comment: Note we store all attachment types - filtering should
    ... X-Comment: be done *before* launchpad is reached. Launchpad is not
    ... X-Comment: a virus checker.
    ...
    ... AAECAw==
    ... --===============0294339828==
    ... Content-Type: text/plain; charset="utf8"
    ... MIME-Version: 1.0
    ... Content-Transfer-Encoding: base64
    ... X-Comment: bas64 encoded text saying 'Unicode(tm)'
    ...
    ... VW5pY29kZeKEoiB0ZXh0
    ...
    ... --===============0294339828==
    ... Content-Type: application/xml; charset="utf16"
    ... MIME-Version: 1.0
    ... Content-Transfer-Encoding: quoted-printable
    ... X-Comment: quoted printable binary with a charset - probably illegal
    ... X-Comment: but we still can cope with it.
    ...
    ... =FF=FE<=00?=00x=00m=00l=00=20=00v=00e=00r=00s=00i=00o=00n=00=3D=00"=001=00.=
    ... =000=00"=00=20=00e=00n=00c=00o=00d=00i=00n=00g=00=3D=00"=00u=00t=00f=001=00=
    ... 6=00"=00?=00>=00
    ... =00<=00u=00n=00i=00c=00o=00d=00e=00>=00"!<=00/=00u=00n=00i=00c=00o=00d=00e=
    ... =00>=00
    ... --===============0294339828==--
    ... The epilogue is not included, including Unicode\N{COPYRIGHT SIGN}
    ... """.encode(
    ...     "latin1"
    ... )  # noqa
    >>> msg = msgset.fromEmail(raw_msg)

Once the email is stuffed into the Message and MessageChunk tables and
relevant bits stuffed into the Librarian, you can deal with them as
normal.

    >>> msg_set = getUtility(IMessageSet)
    >>> msg = msg_set.get(
    ...     rfc822msgid="<20050405054002.22134.71562@localhost.localdomain>"
    ... )[0]
    >>> print(msg.title)
    Unicode™
    >>> chunks = msg.chunks
    >>> for chunk in chunks:
    ...     if chunk.content:
    ...         print("%2d - %s" % (chunk.sequence, pretty(chunk.content)))
    ...
     1 - 'Plain text'
     3 - 'Unicode\u2122 text'

The text_contents attribute contains only the text parts, since that is
what we want to display in the UI.

    >>> print(msg.text_contents)
    Plain text
    <BLANKLINE>
    Unicode™ text

Stripping non-text parts is useful, since a lot of messages will contain
detach GPG signatures, and they shouldn't be shown in the UI since they
add only noise to the comment. For the sake of completeness, since this
has been a problem before, let's look at text_contents of a message
containing a signature.asc attachment.

    >>> from lp.services.compat import message_as_bytes
    >>> from lp.services.mail.tests.helpers import read_test_message
    >>> signed_msg = read_test_message("signed_detached.txt")
    >>> signed_msg["Message-Id"] = "<signeddetached@testmsg>"
    >>> print(signed_msg.as_string())
    Date...
    ...
    Content-Type: multipart/signed; micalg=pgp-sha1;
    ...
    Some signed content.
    <BLANKLINE>
    --'()+_,./:=?vtzGhvizbBRQ85DL
    Content-Type: application/pgp-signature; name="signature.asc"
    ...
    -----BEGIN PGP SIGNATURE-----
    ...
    -----END PGP SIGNATURE-----
    ...

    >>> signed_message = msg_set.fromEmail(message_as_bytes(signed_msg))
    >>> print(signed_message.text_contents)
    Some signed content.

Note that the second and forth chunks of the previous message were not
of type text/plain, so are stored as blobs.

    >>> chunks[1].sequence
    2
    >>> chunks[1].content is None
    True
    >>> blob = chunks[1].blob
    >>> print(blob.filename)
    anna.jpg.exe
    >>> blob.http_url.endswith("/anna.jpg.exe")
    True

    >>> blob2 = chunks[3].blob
    >>> print(blob2.filename)
    unnamed
    >>> print(blob2.mimetype)
    application/xml; charset="utf16"

Only those chunks of content type text/plain with content-disposition
"inline" that have no filename are stored as content. If an inline
text/plain chunk has a filename, it is considered to be an attachment
and is stored as a blob, as well as text/plain chunks with
content-disposition "attachment". Chunks with content-disposition
"attachment" do not need a file name to be stored as blobs. If the chunk
doesn't specify a Content-Type, application/octet-stream will be used as
a default. If the chunk doesn't specify a charset, latin-1 will be
used as a default.

    >>> raw_msg = """\
    ... Content-Type: multipart/mixed; charset="latin-1";
    ...               boundary="=====BOUNDARY====="
    ... MIME-Version: 1.0
    ... Subject: something
    ... From: foo.bar@canonical.com
    ... Message-Id: <20080603@localhost.localdomain>
    ... Date: Thu Mar 06 13:00 MET 2008
    ... To: cabal@ubuntu.com
    ...
    ... --=====BOUNDARY=====
    ... Content-Type: text/plain; charset="us-ascii"
    ... MIME-Version: 1.0
    ... Content-Transfer-Encoding: 7bit
    ...
    ... Plain text
    ... --=====BOUNDARY=====
    ... Content-Type: text/plain;
    ... MIME-Version: 1.0
    ... Content-Transfer-Encoding: 7bit
    ...
    ... Plain text without a ch\u0103\u0155\u015D\u011B\u0163.
    ... --=====BOUNDARY=====
    ... Content-Type: text/plain; charset="us-ascii"
    ... Content-Disposition: inline; filename="attachment.txt"
    ... MIME-Version: 1.0
    ... Content-Transfer-Encoding: 7bit
    ...
    ... some text in a file
    ... --=====BOUNDARY=====
    ... Content-Type: text/plain; charset="us-ascii"
    ... Content-Disposition: attachment
    ... MIME-Version: 1.0
    ... Content-Transfer-Encoding: 7bit
    ...
    ... some text in another file
    ... --=====BOUNDARY=====
    ... Content-Type: text/plain; charset="us-ascii"
    ... Content-Disposition: attachment; filename="attachment2.txt"
    ... MIME-Version: 1.0
    ... Content-Transfer-Encoding: 7bit
    ...
    ... some text in another file
    ... --=====BOUNDARY=====
    ... Content-Disposition: attachment; filename="attachment3.txt"
    ... MIME-Version: 1.0
    ... Content-Transfer-Encoding: 7bit
    ...
    ... some text in another file
    ... --=====BOUNDARY=====
    ... """.encode(
    ...     "UTF-8"
    ... )
    >>> msg = msgset.fromEmail(raw_msg)
    >>> for chunk in msg.chunks:
    ...     if chunk.content is not None:
    ...         print("%d - %s" % (chunk.sequence, pretty(chunk.content)))
    ...     else:
    ...         print(
    ...             "%d - file: %s (%s)"
    ...             % (
    ...                 chunk.sequence,
    ...                 chunk.blob.filename,
    ...                 chunk.blob.mimetype,
    ...             )
    ...         )
    ...
    1 - 'Plain text'
    2 - 'Plain text without a ch\xc4\x83\xc5\x95\xc5\x9d\xc4\x9b\xc5\xa3.'
    3 - file: attachment.txt   (text/plain; charset="us-ascii")
    4 - file: unnamed          (text/plain; charset="us-ascii")
    5 - file: attachment2.txt  (text/plain; charset="us-ascii")
    6 - file: attachment3.txt  (application/octet-stream)

As per normal, we can't access the blobs in the same transaction
as the request. I don't think this is important outside of tests.

    >>> import transaction
    >>> transaction.commit()
    >>> six.ensure_str(blob.read())
    '\x00\x01\x02\x03'

    >>> print(blob2.read().decode("utf16"))
    <?xml version="1.0" encoding="utf16"?>
    <unicode>™</unicode>


We can also retrieve a byte-identical copy of the original message
from the Librarian. This is required for allowing people to verify
the integrity of OpenPGP-signed messages.

    >>> msg.raw.read() == raw_msg
    True

Let's add another multipart message, this time we include a message in
the message, like it is done when forwarding an email.

    >>> forwarded_msg = read_test_message("forwarded-msg.txt")
    >>> msg = msgset.fromEmail(message_as_bytes(forwarded_msg))
    >>> print(msg.text_contents)
    Forwarding test message.
    <BLANKLINE>
    <BLANKLINE>
    Test message.


fromEmail will set the parent of the message as well. We can only set
the parent if it's already in the database, though. To ensure that
threads aren't broken, if the direct parent of the message isn't in the
database, the next parent will be used.

    >>> foo_msg = msgset.fromEmail(
    ...     b"""\
    ... From: foo.bar@canonical.com
    ... Subject: Test
    ... Date: Fri, 17 Jun 2005 10:45:13 +0100
    ... Message-Id: <foo>
    ...
    ... Foo Bar
    ... """
    ... )

    >>> baz_msg = msgset.fromEmail(
    ...     b"""\
    ... From: foo.bar@canonical.com
    ... Subject: Test
    ... Date: Fri, 17 Jun 2005 10:45:13 +0100
    ... Message-Id: <baz>
    ... References: <foo> <bar1> <bar2>
    ...
    ... Foo Bar
    ... """
    ... )

Since <bar1> and <bar2> aren't in the database, the parent will be
set to <foo>

    >>> baz_msg.parent == foo_msg
    True

We can specify a parent to be used, if no parent could be found for the
message. This is useful for bugs, where we want all messages except for
the first one to have a parent.

    >>> bar_msg = msgset.fromEmail(
    ...     b"""\
    ... From: foo.bar@canonical.com
    ... Subject: Test
    ... Date: Fri, 17 Jun 2005 10:45:13 +0100
    ... Message-Id: <bar>
    ...
    ... Bar Baz
    ... """,
    ...     fallback_parent=foo_msg,
    ... )
    >>> bar_msg.parent == foo_msg
    True

The fromEmail method handles non-multipart and minimalist messages
quite happily.

    >>> msg = msgset.fromEmail(
    ...     b"""\
    ... From: foo.bar@canonical.com
    ... Subject: Test
    ... Date: Fri, 17 Jun 2005 10:45:13 +0100
    ... Message-Id: <fnord>
    ...
    ... Foo Bar
    ... """
    ... )
    >>> print(msg.title)
    Test
    >>> chunks = list(msg.chunks)
    >>> len(chunks)
    1
    >>> print(chunks[0].content)
    Foo Bar
    <BLANKLINE>

It also handles the case where the subject line is folded.

    >>> msg = msgset.fromEmail(
    ...     b"""\
    ... From: foo.bar@canonical.com
    ... Subject: Folded
    ...  subject
    ... Date: Fri, 17 Jun 2005 10:45:23 +0100
    ... Message-Id: <foldedsubject>
    ...
    ... Foo Bar
    ... """
    ... )

    >>> print(msg.title)
    Folded subject


However, there are some things it refuses to deal with. In particular, it
will not create Messages if it cannot determine the owner unless it is
explicitly told to do so:

    >>> msg = msgset.fromEmail(
    ...     b"""\
    ... From: invalid@example.com
    ... Date: Fri, 17 Jun 2005 10:45:13 +0100
    ... Message-Id: <fnord3>
    ... Subject: Foo
    ...
    ... Foo Bar
    ... """
    ... )
    Traceback (most recent call last):
        [...]
    lp.services.messages.interfaces.message.UnknownSender:
    'invalid@example.com'

    >>> msg = msgset.fromEmail(
    ...     b"""\
    ... From: invalid@example.com
    ... Date: Fri, 17 Jun 2005 10:45:13 +0100
    ... Message-Id: <fnord3>
    ... Subject: Foo Bar Bazarooney!
    ...
    ... Foo Bar
    ... """,
    ...     create_missing_persons=True,
    ... )
    >>> print(msg.subject)
    Foo Bar Bazarooney!

When the fromEmail() method creates a new Person entry, it'll set the
creation_rationale accordingly.

    >>> msg.owner.creation_rationale.name
    'FROMEMAILMESSAGE'

It also will refuse to deal with messages without a From: or Reply-To:
header, or a missing Message-Id: or Date: header. These are required, and if
they are missing then the email was sent from a broken email client or
passed through a broken MTA and we have no choice but to bounce them.

    >>> msg = msgset.fromEmail(
    ...     b"""\
    ... From: foo.bar@canonical.com
    ... Date: Thu, 16 Jun 2005 14:12:54 +0100
    ... Subject: Dud
    ...
    ... Moo
    ... """
    ... )
    Traceback (most recent call last):
        [...]
    lp.services.messages.interfaces.message.InvalidEmailMessage:
    Missing Message-Id

    >>> msg = msgset.fromEmail(
    ...     b"""\
    ... Date: Fri, 17 Jun 2005 10:45:13 +0100
    ... Subject: Re: Dud
    ... Message-Id: <fnord6>
    ...
    ... Moo
    ... """
    ... )
    Traceback (most recent call last):
        [...]
    lp.services.messages.interfaces.message.InvalidEmailMessage:
    No From: or Reply-To: header

Also, we generally insist that a message has a date associated with it.

    >>> msg = msgset.fromEmail(
    ...     b"""\
    ... From: foo.bar@canonical.com
    ... Subject: Dud without a date!
    ... Message-Id: <fnord6>
    ...
    ... Moo
    ... """
    ... )
    Traceback (most recent call last):
        [...]
    lp.services.messages.interfaces.message.InvalidEmailMessage:
    Invalid date...

However, we can override this behaviour by passing a date_created
parameter to fromEmail(). This is optional, and defaults to None, but it
allows us to deal with those situations where fromEmail() would
otherwise reject the method as invalid.

    >>> from datetime import datetime, timezone

    >>> msg_bytes = b"""\
    ... From: foo.bar@canonical.com
    ... Subject: I have no date! Oh no!
    ... Message-Id: <therearenofnords>
    ...
    ... In search of cheesy comestibles.
    ... """

    >>> date_created = datetime(2008, 7, 9, 14, 27, 40, tzinfo=timezone.utc)
    >>> msg = msgset.fromEmail(msg_bytes, date_created=date_created)

    >>> msg.datecreated
    datetime.datetime(2008, 7, 9, 14, 27, 40, tzinfo=datetime.timezone.utc)

But, we make sure that we don't create a message with a date that is
futuristic:

    >>> msg = msgset.fromEmail(
    ...     b"""\
    ... From: foo.bar@canonical.com
    ... Date: Fri, 17 Jun 2016 10:45:13 +0100
    ... Subject: Re: Back to the future
    ... Message-Id: <fnord19>
    ...
    ... Moo
    ... """
    ... )
    >>> msg.datecreated > datetime.now(tz=timezone.utc)
    False

And similarly, we will consider any message that claims to be older than
1990 to have been created right now:

    >>> msg = msgset.fromEmail(
    ...     b"""\
    ... From: foo.bar@canonical.com
    ... Date: Tue, 17 Jun 1986 10:45:13 +0100
    ... Subject: Re: Back to the future, again
    ... Message-Id: <fnord221>
    ...
    ... Moo
    ... """
    ... )
    >>> thedistantpast = datetime(1990, 1, 1, tzinfo=timezone.utc)
    >>> msg.datecreated < thedistantpast
    False

Finally, let's test the goldilocks message, where the date is just right:

    >>> msg = msgset.fromEmail(
    ...     b"""\
    ... From: foo.bar@canonical.com
    ... Date: Fri, 17 Jun 2005 10:45:13 +0100
    ... Subject: Re: Smells like the present to me
    ... Message-Id: <fnord1221>
    ...
    ... Moo
    ... """
    ... )
    >>> print(msg.datecreated)
    2005-06-17 09:45:13+00:00


Unknown encoding
================

Some mail clients (Pine, for example) send messages with the character set
specified as x-unknown. Python's email package doesn't handle these well and
raises a LookupError, but Message.fromEmail() tries parsing them as latin-1,
which often works.

    >>> import os.path
    >>> mail_path = "../../mail/tests/emails/x-unknown-encoding.txt"
    >>> msg_path = os.path.join(os.path.dirname(__file__), mail_path)
    >>> with open(msg_path, "rb") as f:
    ...     raw_msg = f.read()
    ...
    >>> print(raw_msg.decode("ISO-8859-1"))
    MIME-Version: 1.0
    ...
    Content-Type: TEXT/PLAIN; charset=X-UNKNOWN; format=flowed...
    >>> msg = msgset.fromEmail(raw_msg)

